<h1 id="Implementation-details-for-the-siunitx-extension-for-MathJax"><a href="#Implementation-details-for-the-siunitx-extension-for-MathJax" class="headerlink" title="Implementation details for the siunitx extension for MathJax"></a>Implementation details for the siunitx extension for MathJax</h1><p>The extension is implemented as most other TeX input extension by patching the <code>MathJax.InputJax.TeX</code> class.<br>However, the implementation of these commands is rather complicated and thus deserves some more detailed explanation.<br>The code can be roughly devided into four distinct parts that will be described separately:</p>
<h2 id="1-Top-level-commands"><a href="#1-Top-level-commands" class="headerlink" title="1. Top-level commands"></a>1. Top-level commands</h2><p>siunitx provides a number of commands all centered around formatting SI units and physical quantities involving such units.<br>It uses an extensive array of configuration options to configure various internal settings.<br>Thus, the function of all commands can be built from three basic building blocks;</p>
<ol>
<li>Options parsing</li>
<li>Parsing and formatting of numbers</li>
<li>Parsing and formatting of units</li>
</ol>
<p>The top level commands are implemented by instantiating and combining these components as required.<br>Note that in the current implementation, parsing and formatting are not separated at this level.</p>
<h2 id="2-Options-parsing"><a href="#2-Options-parsing" class="headerlink" title="2. Options parsing"></a>2. Options parsing</h2><p>All options are given as key-value pairs in siunitx, so a dedicated machinery has been implemented for this purpose.<br>Furthermore, the documentation clearly identifies types for each option key.<br>A generic implementation of such a typed key-value list is provided by the class <code>ConfigData</code>.<br>In fact, the types of each key are declared by subclassing that class using the class-method <code>ConfigData.Define</code>,<br>which makes use of JS’s property descriptors to generate runtime type-checked properties on the sub-class.<br>The values are stored in a private sub object <code>_values</code>, which allows to easily generate derived option value sets using<br>JS’s prototyping mechanism (allowing to implement option <em>scopes</em>).</p>
<p>The type validation is done by instances of <code>ValidationBase</code> objects, whose properties specify the exact set of allowed values.<br>There are sub-classes for all types of options used in siunitx, i.e. <code>Switch</code> for simple true/false options, <code>Integer</code> for<br>integer numbers or <code>TeXParsedLiteral</code> accepting TeX literals which are supposed to be pre-parsed<br>(TODO: pre-parsing is not done, I didn’t find out how to clone MML instances).</p>
<p>The design allows for easy scoping and possibly interoperation with the <code>grouping</code> extension<br>(or how was it called again, the one allowing for TeX groups?)<br>Surely, the currently unimplemented <code>\sisetup</code> command should be trivial with this framework.</p>
<h2 id="3-Number-parsing-and-formatting"><a href="#3-Number-parsing-and-formatting" class="headerlink" title="3. Number parsing and formatting"></a>3. Number parsing and formatting</h2><p>siunitx provides many options for number transformation and rendering.<br>Unfortunately, it is not completely clear to me what exactly is allowed to write numbers in siunitx.<br>Current personal experience seems to suggest that numbers are only accepted exactly as specified (which covers a wide set of notation).<br>The current implementation uses regexes to capture the numbers, but they are not really parsed as numbers.<br>Instead, they are in-place transformed into LaTeX formatting for output as intended by siunitx.<br>Then, the standard <code>MathJax.InputJax.TeX</code> parser is used to generate the MML.</p>
<p>The current approach is limited, as it does not allow for more complicated rewriting options provided by siunitx.<br>Instead, parsing and output should be separated completely, and ideally no more intermediate TeX should be required.</p>
<h2 id="4-Units-parsing-and-formatting"><a href="#4-Units-parsing-and-formatting" class="headerlink" title="4. Units parsing and formatting"></a>4. Units parsing and formatting</h2><p>siunitx essentially knows two ways to specify units: macro units and the literal units.<br>According to Joseph Wright, in literal mode, everything is passed to LaTeX as is, except for some ‘string replacement’.<br>Macros are parsed into a structure.<br>If anything literal is present, the whole unit specification is parsed literally.<br>This is taken over to this implementation.<br>A subclass of <code>MathJax.InputJax.TeX</code> is created that knows all of the units known to siunitx.<br>The input is then parsed as usual, the unit macros build an internal structure step by step.<br>At the same time, they <code>this.PushUnitFallBack</code> the fallback output for literal mode.<br>Literal mode is detected inside a patched <code>this.Push</code>, which get’s invoked from any parser code that does not know about siunitx macros.<br>If any such literal input is detected, the normally parsed output will be given, otherwise the output is generated from<br>the internal structure.<br>That internal structure contains prefixes, qualifications, powers and the actual unit.</p>
<p>The current implementation works quite well, except that the generated MML is probably suboptimal.<br>In fact, the MML unit specification would allow to embed information that makes machine processing of the units possible.<br>An interesting avenue would certainly be a menu entry to convert the numbers into other units systems, but is out of scope of the siunitx extension.</p>
<h2 id="Conclusion-TODO’s"><a href="#Conclusion-TODO’s" class="headerlink" title="Conclusion: TODO’s"></a>Conclusion: TODO’s</h2><p>I see three general areas that call for improvement:</p>
<ol>
<li>MML ouput quality. I don’t know MML well enough, neither it’s representation in MathJax.<br>Therefore, I just copy-pasted from other code to produce something that remotely looks ok.<br>However, someone with more insight into MathJax should definitely go over this.<br>On a side note, I was unable to find a way to clone MML structures, so currently the MML is generated every time anew,<br>even when e.g. repeated units could profit from a clone.</li>
<li>Number parsing/formatting: Many rewriting options offered by siunitx are unavailable and hard to implement with the<br>current design, where numbers are never completely interpreted.</li>
<li>Options scoping. The <code>\sisetup</code> command is not implemented, and neither is the <code>this.stack.env</code> environment used,<br>since I never really took the time to dive into that.</li>
</ol>
